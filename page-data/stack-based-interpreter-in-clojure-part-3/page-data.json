{"componentChunkName":"component---node-modules-gatsby-theme-code-notes-src-templates-note-js","path":"/stack-based-interpreter-in-clojure-part-3","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Stack Based Interpreter In Clojure - Part 3\",\n  \"tags\": [\"clojure\", \"data-structions\", \"stack\", \"interpreter\"],\n  \"emoji\": \"ðŸ‘‹\",\n  \"link\": \"https://nerds-den.com/stack-based-interpreter-in-clojure-part-3\",\n  \"modified\": \"2021-06-14T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In part two we we built a stack that we can use to store our operands. The next step for you is to define insstructions taht allow us to perform operations on the operands in the stack.\"), mdx(\"p\", null, \"In case you missed the definitions in part one let's recap what we need to make instructions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"name\"), \" - Technically this is optional, but I'll be damned if I'm going to use a machine where I have to remeber the opcodes of our instructions\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"opcode\"), \" - A unique number for this instruction. It's important that this doesn't change between interpreter versions otherwise we won't be able to run old code.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"arity\"), \" - The number of arguments this instruction takes: that depends on the number of operands it pops from the stack.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"behavior\"), \" - The action that our instruction will perform. In a CPU this is made using transistors but in our case we'll use Clojure functions.\")), mdx(\"p\", null, \"With all that in mind, let's build our instruction type. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(ns com.vadelabs.instruction.core)\\n\\n(defprotocol IInstruction\\n  (get-op-code [this])\\n  (get-name [this])\\n  (arity [this])\\n  (function [this]))\\n\\n(defrecord Instruction [op-code name arity function]\\n  IInstruction\\n  (get-op-code [this]\\n    (get-in this [:op-code]))\\n  (get-name [this]\\n    (get-in this [:name]))\\n  (arity [this] (get this :arity))\\n  (function [this] (get this :function)))\\n\\n(defn make-instruction\\n  [op-code name arity func]\\n  (map->Instruction {:op-code op-code\\n                     :name name\\n                     :arity arity\\n                     :function func}))\\n\\n\")), mdx(\"p\", null, \"Next we need an instruction table - a structure which we can store instructions in and look them up by opcode and name. We're going to use a Clojure Map.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(ns com.vadelabs.instruction.table\\n  (:refer-clojure :exclude [empty?])\\n  (:require\\n   [com.vadelabs.instruction.core :as instruction]))\\n\\n(defprotocol ITable\\n  (by-op-code [this op-code])\\n  (by-name [this n])\\n  (insert [this instr])\\n  (empty? [this])\\n  (symbols [this]))\\n\\n(defrecord Table [table]\\n  ITable\\n  (by-op-code [this op-code]\\n    (get-in this [:table op-code]))\\n\\n  (by-name [this n]\\n    (first (filter (fn [item]\\n                     (= n (instruction/get-name item)))\\n                   (vals (get-in this [:table])))))\\n\\n  (insert [this instr]\\n    (assoc-in this [:table (:op-code instr)] instr))\\n\\n  (empty? [this]\\n    (clojure.core/empty? (:table this)))\\n\\n  (symbols [this]\\n    (let [result (map (fn [k]\\n                        (let [instr (get-in this [:table k])]\\n                          [(instruction/get-op-code instr) (instruction/get-name instr)]))\\n                      (keys table))]\\n      (sort-by first result))))\\n\\n(defn make-instruction-table\\n  []\\n  (map->Table {:table {}}))\\n\\n\")), mdx(\"p\", null, \"We've come to the end of today's journey. We now have an operand stack, and a way to collect and use our instructions. In our next post we're going to create the necessary structures to represent a program that our stack machine can execute. \"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 3","tags":["clojure","data-structions","stack","interpreter"],"emoji":"ðŸ‘‹","link":"https://nerds-den.com/stack-based-interpreter-in-clojure-part-3","modified":"June 14, 2021","modifiedTimestamp":"2021-06-14T00:00:00.000Z"},"references":[],"fields":{"slug":"/stack-based-interpreter-in-clojure-part-3"},"tableOfContents":{},"parent":{"relativePath":"stack-based-interpreter-in-clojure-part-3.md"}}},"pageContext":{"id":"3393da82-dd25-5f89-973e-a9f10ff42026","previous":{"id":"0a3fdc0b-090b-5100-a74a-0aebe5df6997","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 4","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-4"}},"next":{"id":"60b2018e-b990-5d37-ab6b-e026cfc4cb7f","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 2","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-2"}},"hasUntagged":false,"basePath":"/","tags":[{"tag":"about","totalCount":1,"slug":"/about","path":"/tag/about"},{"tag":"clojure","totalCount":9,"slug":"/clojure","path":"/tag/clojure"},{"tag":"data-structions","totalCount":8,"slug":"/data-structions","path":"/tag/data-structions"},{"tag":"interpreter","totalCount":8,"slug":"/interpreter","path":"/tag/interpreter"},{"tag":"stack","totalCount":8,"slug":"/stack","path":"/tag/stack"}]}},"staticQueryHashes":["1308211557","2744905544","467212769"]}