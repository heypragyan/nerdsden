{"componentChunkName":"component---node-modules-gatsby-theme-code-notes-src-templates-note-js","path":"/stack-based-interpreter-in-clojure-part-1","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Stack Based Interpreter In Clojure - Part 1\",\n  \"tags\": [\"clojure\", \"data-structions\", \"stack\", \"interpreter\"],\n  \"emoji\": \"ðŸ‘‹\",\n  \"link\": \"https://nerds-den.com/stack-based-interpreter-in-clojure-part-1\",\n  \"modified\": \"2021-06-14T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I recently got a task to implement a simple stack based interpreter in clojure to interview for a clojure developer position. Building an interpreter is a good excercise to learn any programming language. It uses all the tools in a programmer's arsenal and gives you plenty of opportunity to flex your brain muscle. If you can make a working programming language using a particular tool then you can make almost anything your customer or employer desires\"), mdx(\"h2\", {\n    \"id\": \"what-is-a-stack-based-interpreter\"\n  }, \"What is a stack based interpreter?\"), mdx(\"p\", null, \"There are three main type of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Von_Neumann_architecture\"\n  }, \"Von Neumann Machines\"), \":\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Accumulator - The most basic form of processor where only a single register is used to store the results of computation.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Stack - Stack machines use an operand stack to push and pop results off the top\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Register - Register machiens use a number of named (or numbered) registers to store values or pass arguments.\")), mdx(\"p\", null, \"As far as I can tell most dynamic language interpreters are stack machines. I expect that this is largely due to the fact that they're a little easier to write and you don't have to keep track of your register usage when writing your assembly.\"), mdx(\"p\", null, \"Interestingly both stack and register machines can emulate each other which makes sense since we run them all on physical processors which are usually register machines.\"), mdx(\"p\", null, \"You can think of a stack as something as simple as an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \". When you initialize your machine the stack is empty and each instruction executed by the machine can pop values off the top of the stack and push values onto the stack. Say we start with the simple calculator example and add two numbers:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Initialize Machine - (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[]\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"push\"), \" instruction to add the number 2 onto the stack -\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"push 2\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[2]\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Push the number 3 onto the stack - \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"push 3\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[2 3]\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add\"), \" instruction to pop two items off the stack and push back the result - \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[5]\"), \")\")), mdx(\"p\", null, \"Hopefully that gives you enough basic idea of how a stack machine works.\"), mdx(\"h2\", {\n    \"id\": \"stack-machine-terminology\"\n  }, \"Stack machine terminology\"), mdx(\"p\", null, \"Here's a few basic terms that we're going to use in the course of this series:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Stack\"), \" - A pile of values, usually in the form of an array or list where values can be added and removed from the \\\"top\\\" only.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Operand\"), \" - The values that are being added and removed to the stack and operated upon by the instructions.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Instruction\"), \" - The smallest unit of behavior in our machine. Instructions can pop operants off the stack, operate on them, and then push results back onto the stack. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"OpCode\"), \" - Short for operation code. A unique number which corresponds to a specific instruction to allow programs to be serialized more compactly than using their names.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Program\"), \" - A list of instructions (usually by opcode) and their operand arguments for the machine to execute.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Instruction Pointer\"), \" - The index into the program which keeps track of the currently executing (or next) instruction.\")), mdx(\"p\", null, \"There are few others, that we will cover as we progress.\"), mdx(\"p\", null, \"Want to dig deeper into the code? Checkout Part 2.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 1","tags":["clojure","data-structions","stack","interpreter"],"emoji":"ðŸ‘‹","link":"https://nerds-den.com/stack-based-interpreter-in-clojure-part-1","modified":"June 14, 2021","modifiedTimestamp":"2021-06-14T00:00:00.000Z"},"references":[],"fields":{"slug":"/stack-based-interpreter-in-clojure-part-1"},"tableOfContents":{"items":[{"url":"#what-is-a-stack-based-interpreter","title":"What is a stack based interpreter?"},{"url":"#stack-machine-terminology","title":"Stack machine terminology"}]},"parent":{"relativePath":"stack-based-interpreter-in-clojure-part-1.md"}}},"pageContext":{"id":"671514ab-76b6-5989-a3d8-b84d55267d24","previous":{"id":"60b2018e-b990-5d37-ab6b-e026cfc4cb7f","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 2","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-2"}},"next":{"id":"0a5243ae-a72e-527c-9023-45e21ef167dd","frontmatter":{"title":"About Me","tags":["about","clojure"]},"fields":{"slug":"/about-me"}},"hasUntagged":false,"basePath":"/","tags":[{"tag":"about","totalCount":1,"slug":"/about","path":"/tag/about"},{"tag":"clojure","totalCount":9,"slug":"/clojure","path":"/tag/clojure"},{"tag":"data-structions","totalCount":8,"slug":"/data-structions","path":"/tag/data-structions"},{"tag":"interpreter","totalCount":8,"slug":"/interpreter","path":"/tag/interpreter"},{"tag":"stack","totalCount":8,"slug":"/stack","path":"/tag/stack"}]}},"staticQueryHashes":["1308211557","2744905544","467212769"]}