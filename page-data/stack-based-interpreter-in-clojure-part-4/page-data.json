{"componentChunkName":"component---node-modules-gatsby-theme-code-notes-src-templates-note-js","path":"/stack-based-interpreter-in-clojure-part-4","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Stack Based Interpreter In Clojure - Part 4\",\n  \"tags\": [\"clojure\", \"data-structions\", \"stack\", \"interpreter\"],\n  \"emoji\": \"ðŸ‘‹\",\n  \"link\": \"https://nerds-den.com/stack-based-interpreter-in-clojure-part-4\",\n  \"modified\": \"2021-06-14T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"We now have our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"instructions\"), \" and our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"stack\"), \", we need a program that we can run.\"), mdx(\"p\", null, \"Let's call this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Code\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(ns com.vadelabs.code.core\\n  (:refer-clojure :exclude [empty])\\n  (:require\\n   [com.vadelabs.code.builder :as vm.builder]\\n   [com.vadelabs.instruction.interface :as vm.instruction]))\\n\\n(defprotocol ICode\\n  (symbols [this])\\n  (-code [this])\\n  (-data [this])\\n  (labels [this])\\n  (label-ip [this item]))\\n\\n(defrecord Code [symbols code data labels]\\n  ICode\\n  (symbols [this]\\n    (get-in this [:symbols]))\\n  (-code [this]\\n    (get-in this [:code]))\\n  (-data [this]\\n    (get-in this [:data]))\\n  (labels [this]\\n    (get-in this [:labels]))\\n  (label-ip [this item]\\n    (ffirst (filter\\n             (fn [label]\\n               (= (second label) item))\\n             (get-in this [:labels])))))\\n\\n(defn data\\n  ([code]\\n   (-> code (-data)))\\n  ([code idx]\\n   (-> code (-data) (get idx))))\\n\\n(defn code\\n  ([code]\\n   (-> code (-code)))\\n  ([code idx]\\n   (-> code (-code) (get idx))))\\n\\n(defn make-code\\n  ([]\\n   (map->Code {:symbols []\\n               :code []\\n               :data []\\n               :labels []}))\\n  ([builder]\\n   (let [symbols (into [] (-> builder\\n                              (vm.builder/instruction-table)\\n                              (vm.instruction/symbols)))\\n         code (-> builder\\n                  (vm.builder/instructions))\\n         data (-> builder\\n                  (vm.builder/data))\\n         label-map (-> builder (vm.builder/labels))\\n         labels (map (fn [label] [(get label-map label) label]) (keys label-map))\\n         labels (into [] (sort-by first labels))]\\n     (map->Code {:symbols symbols\\n                 :code code\\n                 :data data\\n                 :labels labels}))))\\n\\n\")), mdx(\"p\", null, \"Here's our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Builder\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(ns com.vadelabs.code.builder\\n  (:require\\n   [com.vadelabs.instruction.interface :as vm.instruction]))\\n\\n(defprotocol IBuilder\\n  (push [this item args])\\n  (push-data [this args])\\n  (instruction-table [this])\\n  (instructions [this])\\n  (labels [this])\\n  (add-label [this item])\\n  (data [this])\\n  (lenth [this]))\\n\\n(defrecord Builder [instruction-table instructions labels data]\\n  IBuilder\\n  (push-data [this args]\\n    (let [data-items (apply conj (get-in this [:data]) args)]\\n      (-> this\\n          (assoc-in [:data] (into [] (distinct data-items))))))\\n\\n  (push [this item args]\\n    (let [it (get-in this [:instruction-table])\\n          instr (vm.instruction/by-name it item)\\n          arity (vm.instruction/arity instr)\\n          _ (when-not instr\\n              (throw (Exception. (ex-info \\\"Unable to find instruction\\\" {:name item}))))\\n          _ (when-not (= (count args) arity)\\n              (throw (Exception. (ex-info \\\"Instruction has different arity than passed arguments\\\"\\n                                          {:name item\\n                                           :arity arity\\n                                           :args (count args)}))))\\n          builder (-> this (push-data args))\\n          indices (map (fn [arg]\\n                         (.indexOf (-> builder (get-in [:data])) arg))\\n                       args)\\n          ;; indices (map-indexed (fn [idx _] idx) (-> builder (get-in [:data])))\\n          instrs (apply conj instructions\\n                        (vm.instruction/op-code instr)\\n                        (vm.instruction/arity instr)\\n                        indices)]\\n      (assoc-in builder [:instructions] instrs)))\\n\\n  (instruction-table [this]\\n    (get-in this [:instruction-table]))\\n  (instructions [this]\\n    (get-in this [:instructions]))\\n  (labels [this]\\n    (get-in this [:labels]))\\n  (data [this]\\n    (get-in this [:data]))\\n  (add-label [this item]\\n    (let [idx (count instructions)]\\n      (update-in this [:labels] assoc item idx))))\\n\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 4","tags":["clojure","data-structions","stack","interpreter"],"emoji":"ðŸ‘‹","link":"https://nerds-den.com/stack-based-interpreter-in-clojure-part-4","modified":"June 14, 2021","modifiedTimestamp":"2021-06-14T00:00:00.000Z"},"references":[],"fields":{"slug":"/stack-based-interpreter-in-clojure-part-4"},"tableOfContents":{},"parent":{"relativePath":"stack-based-interpreter-in-clojure-part-4.md"}}},"pageContext":{"id":"0a3fdc0b-090b-5100-a74a-0aebe5df6997","previous":{"id":"1e06b1ee-8e63-559c-bb43-a9c61ac9ab6f","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 5","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-5"}},"next":{"id":"3393da82-dd25-5f89-973e-a9f10ff42026","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 3","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-3"}},"hasUntagged":false,"basePath":"/","tags":[{"tag":"about","totalCount":1,"slug":"/about","path":"/tag/about"},{"tag":"clojure","totalCount":9,"slug":"/clojure","path":"/tag/clojure"},{"tag":"data-structions","totalCount":8,"slug":"/data-structions","path":"/tag/data-structions"},{"tag":"interpreter","totalCount":8,"slug":"/interpreter","path":"/tag/interpreter"},{"tag":"stack","totalCount":8,"slug":"/stack","path":"/tag/stack"}]}},"staticQueryHashes":["1308211557","2744905544","467212769"]}