{"componentChunkName":"component---node-modules-gatsby-theme-code-notes-src-templates-note-js","path":"/stack-based-interpreter-in-clojure-part-2","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Stack Based Interpreter In Clojure - Part 2\",\n  \"tags\": [\"clojure\", \"data-structions\", \"stack\", \"interpreter\"],\n  \"emoji\": \"ðŸ‘‹\",\n  \"link\": \"https://nerds-den.com/stack-based-interpreter-in-clojure-part-2\",\n  \"modified\": \"2021-06-14T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In part one we didn't delve into any code. Let's fix that now.\"), mdx(\"p\", null, \"If you are an impatient soul and wish to jump onto the completed source code, you can find it \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/heypragyan/rplvm\"\n  }, \"here\")), mdx(\"p\", null, \"The first thing you need to build a stack machine. Stack machine is a stack: a data structure that we can push and pop operands into/out of. Because we are using Clojure that means we're going to use a List and we need it to be generic.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(defprotocol IStack\\n  (empty? [this])\\n  (push [this item])\\n  (pop [this])\\n  (peek [this])\\n  (get [this])\\n  (set [this stack])\\n  (clear-stack [this]))\\n\\n(defrecord Stack [stack]\\n  IStack\\n\\n  (empty? [this]\\n    (clojure.core/empty? (get-in this [:stack])))\\n\\n  (push [this item]\\n    (update-in this [:stack] conj item))\\n\\n  (pop [this]\\n    (as-> this $\\n      (update-in $ [:stack] clojure.core/pop)))\\n\\n  (peek [this]\\n    (first (get-in this [:stack])))\\n\\n  (get [this]\\n    (-> this :stack))\\n\\n  (set [this stack]\\n    (assoc this :stack stack))\\n\\n  (clear-stack [this]\\n    (assoc this :stack (clojure.core/empty (:stack this)))))\\n\\n(defn make-stack []\\n  (map->Stack {:stack '()}))\\n\\n\")), mdx(\"p\", null, \"In the next part we will figure out what is an instruction, how to build one, and initiate an instruction table to store them.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 2","tags":["clojure","data-structions","stack","interpreter"],"emoji":"ðŸ‘‹","link":"https://nerds-den.com/stack-based-interpreter-in-clojure-part-2","modified":"June 14, 2021","modifiedTimestamp":"2021-06-14T00:00:00.000Z"},"references":[],"fields":{"slug":"/stack-based-interpreter-in-clojure-part-2"},"tableOfContents":{},"parent":{"relativePath":"stack-based-interpreter-in-clojure-part-2.md"}}},"pageContext":{"id":"60b2018e-b990-5d37-ab6b-e026cfc4cb7f","previous":{"id":"3393da82-dd25-5f89-973e-a9f10ff42026","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 3","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-3"}},"next":{"id":"671514ab-76b6-5989-a3d8-b84d55267d24","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 1","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-1"}},"hasUntagged":false,"basePath":"/","tags":[{"tag":"about","totalCount":1,"slug":"/about","path":"/tag/about"},{"tag":"clojure","totalCount":9,"slug":"/clojure","path":"/tag/clojure"},{"tag":"data-structions","totalCount":8,"slug":"/data-structions","path":"/tag/data-structions"},{"tag":"interpreter","totalCount":8,"slug":"/interpreter","path":"/tag/interpreter"},{"tag":"stack","totalCount":8,"slug":"/stack","path":"/tag/stack"}]}},"staticQueryHashes":["1308211557","2744905544","467212769"]}