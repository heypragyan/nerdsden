{"componentChunkName":"component---node-modules-gatsby-theme-code-notes-src-templates-note-js","path":"/stack-based-interpreter-in-clojure-part-5","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Stack Based Interpreter In Clojure - Part 5\",\n  \"tags\": [\"clojure\", \"data-structions\", \"stack\", \"interpreter\"],\n  \"emoji\": \"ðŸ‘‹\",\n  \"link\": \"https://nerds-den.com/stack-based-interpreter-in-clojure-part-5\",\n  \"modified\": \"2021-06-14T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In previous post we built a code generator and a program representation so we now have all but that last bit we need to run our interpreter.\"), mdx(\"h2\", {\n    \"id\": \"intruducing-the-stack-machine\"\n  }, \"Intruducing the stack machine\"), mdx(\"p\", null, \"So far we've built all the primary structions required to assemble our program, we have \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"code\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"instructions\"), \", and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"stack\"), \". The last major thing we need to do before we can run our programs is the machine itself. \"), mdx(\"p\", null, \"Here's our stack machine:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(ns com.vadelabs.machine.core\\n  (:require\\n   [com.vadelabs.stack.interface :as vm.stack]\\n   [com.vadelabs.code.interface :as vm.code]\\n   [com.vadelabs.instruction.interface :as vm.instruction]\\n   [com.vadelabs.machine.frame :as frame]))\\n\\n(defprotocol IMachine\\n  (operand-push [this value])\\n  (operand-pop  [this])\\n  (operand-peek [this])\\n  (operand-stack [this])\\n  (call-stack [this])\\n  (ip [this])\\n  (inc-ip [this])\\n  (code [this])\\n  (data [this idx])\\n  (execute [this])\\n  (next-code [this])\\n  (get-local [this n])\\n  (set-local [this k v])\\n  (jump [this label])\\n  (call [this label])\\n  (ret [this])\\n  (process-code [this]))\\n\\n(defrecord Machine [code process-code instruction-table ip constants call-stack operand-stack]\\n  IMachine\\n  (operand-push [this value]\\n    (assoc-in this [:operand-stack]\\n              (vm.stack/push (get-in this [:operand-stack]) value)))\\n\\n  (operand-pop [this]\\n    (as-> this $\\n      (assoc-in $ [:operand-stack] (vm.stack/pop operand-stack))))\\n\\n  (operand-peek [_]\\n    (vm.stack/peek operand-stack))\\n\\n  (data [_ idx]\\n    (vm.code/code-data code idx))\\n\\n  (code [this]\\n    (get-in this [:code]))\\n\\n  (ip [this]\\n    (get-in this [:ip]))\\n\\n  (call-stack [this]\\n    (get-in this [:call-stack]))\\n\\n  (operand-stack [this]\\n    (get-in this [:operand-stack]))\\n\\n  (next-code [this]\\n    (let [instr-ptr (get-in this [:ip])\\n          code (-> this\\n                   (get-in [:code])\\n                   (vm.code/code instr-ptr))\\n          new-ip (+ instr-ptr 1)]\\n      (assoc this :process-code code :ip new-ip)))\\n\\n  (get-local [this n]\\n    (-> this\\n        (get :call-stack)\\n        (vm.stack/peek)\\n        (frame/get-local n)))\\n\\n  (set-local [this k v]\\n    (let [cs (get this :call-stack)\\n          fr (vm.stack/peek cs)\\n          fs (vm.stack/pop cs)\\n          final-frame (frame/set-local fr k v)]\\n      (assoc-in this [:call-stack] (vm.stack/push fs final-frame))))\\n\\n  (jump [this label]\\n    (assoc-in this [:ip] (-> this\\n                             (get :code)\\n                             (vm.code/code-label-ip label))))\\n\\n  (call [this label]\\n    (let [ip (get this :ip)\\n          machine (assoc this :call-stack\\n                         (vm.stack/push (get this :call-stack)\\n                                        (frame/make-frame ip)))]\\n      (jump machine label)))\\n\\n  (ret [this]\\n    (let [frame (vm.stack/peek (get this :call-stack))\\n          machine (assoc this :call-stack (vm.stack/pop (get this :call-stack)))]\\n      (assoc machine :ip (frame/return-address frame))))\\n\\n  (execute [this]\\n    (loop [machine this]\\n      (if (= (get machine :ip) (count (vm.code/code code)))\\n        machine\\n        (let [op-code (-> machine (next-code) (get :process-code))\\n              arity (-> machine (next-code) (next-code) (get :process-code))\\n              instr (vm.instruction/by-op-code instruction-table op-code)\\n              [machine args] (loop [machine (-> machine (next-code) (next-code))\\n                                    result []]\\n                               (if (= (count result) arity)\\n                                 [machine result]\\n                                 (recur (-> machine (next-code))\\n                                        (conj result (-> machine (next-code) (get :process-code))))))\\n              func (vm.instruction/function instr)\\n              final-machine (func machine args)]\\n          (recur final-machine))))))\\n\\n(defn make-machine\\n  [code constants instruction-table]\\n  (let [stack-frame (frame/make-frame (count (vm.code/code code)))\\n        call-stack  (-> (vm.stack/make-stack)\\n                        (vm.stack/push stack-frame))]\\n    (map->Machine {:code code\\n                   :instruction-table instruction-table\\n                   :ip 0\\n                   :constants constants\\n                   :call-stack call-stack\\n                   :operand-stack (vm.stack/make-stack)})))\\n\\n\")), mdx(\"p\", null, \"So when we create our machine we pass in our code and our instruction table. It sets the instruction pointer to zero (the first instruction in the code), creates and empty stack and returns our new machine. \"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 5","tags":["clojure","data-structions","stack","interpreter"],"emoji":"ðŸ‘‹","link":"https://nerds-den.com/stack-based-interpreter-in-clojure-part-5","modified":"June 14, 2021","modifiedTimestamp":"2021-06-14T00:00:00.000Z"},"references":[],"fields":{"slug":"/stack-based-interpreter-in-clojure-part-5"},"tableOfContents":{"items":[{"url":"#intruducing-the-stack-machine","title":"Intruducing the stack machine"}]},"parent":{"relativePath":"stack-based-interpreter-in-clojure-part-5.md"}}},"pageContext":{"id":"1e06b1ee-8e63-559c-bb43-a9c61ac9ab6f","previous":{"id":"cbd0325b-c80b-58c8-94a9-b9a05c8204fd","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 6","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-6"}},"next":{"id":"0a3fdc0b-090b-5100-a74a-0aebe5df6997","frontmatter":{"title":"Stack Based Interpreter In Clojure - Part 4","tags":["clojure","data-structions","stack","interpreter"]},"fields":{"slug":"/stack-based-interpreter-in-clojure-part-4"}},"hasUntagged":false,"basePath":"/","tags":[{"tag":"about","totalCount":1,"slug":"/about","path":"/tag/about"},{"tag":"clojure","totalCount":9,"slug":"/clojure","path":"/tag/clojure"},{"tag":"data-structions","totalCount":8,"slug":"/data-structions","path":"/tag/data-structions"},{"tag":"interpreter","totalCount":8,"slug":"/interpreter","path":"/tag/interpreter"},{"tag":"stack","totalCount":8,"slug":"/stack","path":"/tag/stack"}]}},"staticQueryHashes":["1308211557","2744905544","467212769"]}